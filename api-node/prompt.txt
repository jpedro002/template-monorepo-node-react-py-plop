quero "automatizar" a criação de rotas do backend com plop js

tenho esse base controler em express com js 

import { prisma } from 'src/services'

function BaseController(model, params = { include, select }) {
  const { select = null, include = null } = params

  async function all(req, res, next) {
    try {
      const { fields: dbFields } = prisma[model].getDatabase()
      const { fields = [], term = null, order = null } = req.query
  
      let predicate = { where: {} }
      
      if (term && fields && Array.isArray(fields)) {
        const isNumeric = !isNaN(Number(term)) && term !== '';
        const numericValue = isNumeric ? Number(term) : null;
        
        const validConditions = fields
          .map((m) => {
            if (m.includes('.')) {
              const parts = m.split('.');
              
              if (parts.length === 2) {
                const [field1, field2] = parts;
                return { 
                  [field1]: { 
                    [field2]: { contains: term, mode: 'insensitive' } 
                  } 
                };
              } 
              else if (parts.length === 3) {
                const [field1, field2, field3] = parts;
                return { 
                  [field1]: { 
                    [field2]: { 
                      [field3]: { contains: term, mode: 'insensitive' } 
                    } 
                  } 
                };
              }
              return null;
            }
            
            const dbField = dbFields.find((o) => o.name === m);
            if (!dbField) return null;
            
            const fieldType = dbField.type.toLowerCase();
            
            if (['int', 'integer', 'float', 'decimal'].includes(fieldType)) {
              return isNumeric ? { [m]: { equals: numericValue } } : null;
            } else {
              return { [m]: { contains: term, mode: 'insensitive' } };
            }
          })
          .filter(Boolean);
        
        if (validConditions.length > 0) {
          predicate = {
            where: {
              OR: validConditions
            }
          };
        }
      }
  
      const [rowCount, data] = await prisma.$transaction([
        prisma[model].count(predicate),
        prisma[model].findMany({
          ...predicate,
          orderBy: order ? { [order]: 'asc' } : {},
          select: select,
          include: include,
        }),
      ])
  
      res.json({ data, rowCount })
    } catch (error) {
      next(error)
    }
  }
  
  async function fetch(req, res, next) {
    try {
      const { fields: dbFields } = prisma[model].getDatabase()
      const { fields = [], term = null, order = null, page = 1, pageSize = 20, itens = [] } = req.query

      let predicate = { where: {} }

      // Adiciona filtro de itens, se existir
      if (Array.isArray(itens) && itens.length > 0) {
        predicate.where.id = { in: itens.map(Number) }
      }

      // Adiciona filtro de busca por termo
      if (term && fields && Array.isArray(fields)) {
        predicate.where.OR = fields.map((m) => {
          if (m.includes('.')) {
            const [field1, field2] = m.split('.')
            return { [field1]: { [field2]: { contains: term, mode: 'insensitive' } } }
          }
          const dbField = dbFields.find((o) => o.name === m)
          return {
            [m]: ['int'].includes(dbField.type.toLowerCase())
              ? { equals: Number(term) }
              : { contains: term, mode: 'insensitive' },
          }
        })
      }

      const [rowCount, data] = await prisma.$transaction([
        prisma[model].count({ ...predicate }),
        prisma[model].findMany({
          ...predicate,
          take: Number(pageSize),
          skip: (Number(page) - 1) * Number(pageSize),
          orderBy: order ? { [order]: 'asc' } : {},
          select: select,
          include: include,
        }),
      ])

      res.json({
        data,
        pagination: { page: Number(page), rowCount, pageCount: Math.ceil(rowCount / pageSize) || 1 },
      })
    } catch (error) {
      next(error)
    }
  }

  async function one(req, res, next) {
    try {
      const { id } = req.params
      const data = await prisma[model].findUnique({
        where: { id: Number(id) },
        select: select,
        include: include,
      })
      if (!data) throw new Error('Registro não localizado.')
      res.json(data)
    } catch (error) {
      next(error)
    }
  }

  async function post(req, res, next) {
    try {
      const body = req.body
      if ('id' in body) delete body.id
      const data = await prisma[model].create({
        data: { ...body },
        select: select,
        include: include,
      })
      res.json(data)
    } catch (error) {
      next(error)
    }
  }

  async function put(req, res, next) {
    try {
      const { id } = req.params
      const body = req.body
      if ('id' in body) delete body.id
      const data = await prisma[model].update({
        data: { ...body },
        where: { id: Number(id) },
        select: select,
        include: include,
      })
      res.json(data)
    } catch (error) {
      next(error)
    }
  }

  async function del(req, res, next) {
    try {
      const { id } = req.params
      await prisma[model].delete({
        where: { id: Number(id) },
      })
      res.status(204).send()
    } catch (error) {
      next(error)
    }
  }

  return { all, fetch, one, post, put, del }
}

const conectarCamposId = (camposId = []) => {
  const retorno = camposId?.reduce((acc, item) => {
    const nomeCampo = item?.label
    if (!item.value) throw new Error(`O campo ${nomeCampo?.replace('_', ' ')?.toUpperCase()} não foi informado!`)
    acc[nomeCampo] = { connect: { id: item.value } }
    return acc
  }, {})

  return retorno
}

export { BaseController, conectarCamposId }

aquo um exemplo de uso dele 
import { Prisma } from '@prisma/client'
import { BaseController } from 'src/controllers'
import { prisma } from 'src/services'

const PerfisController = () => {
  const model = 'perfil'
  const include = { permissoes: { include: { funcionalidade: true } } }
  const base = BaseController(model, { include: include })

  async function postPermissoes(req, res, next) {
    try {
      const body = req.body
      if ('id' in body) delete body.id
      await prisma.$transaction(async (tr) => {
        const query = `DELETE FROM seguranca.permissoes WHERE perfil_id = ${body.perfil_id};`
        await tr.$executeRaw(Prisma.raw(query))
        await tr.permissao.createMany({
          data: body.funcionalidade_id.map((m) => ({
            perfil_id: Number(body.perfil_id),
            funcionalidade_id: Number(m),
          })),
        })
      })
      res.send()
    } catch (error) {
      next(error)
    }
  }

  return { ...base, postPermissoes }
}

export { PerfisController }
export default PerfisController

aqui um exemplo da parte de rotas 

import express from 'express'
import { AuthController, PerfisController } from 'src/controllers'
import baseRoute from 'src/routes/base'

const { verifyJWT } = AuthController()
const { postPermissoes } = PerfisController()
const base = baseRoute(PerfisController)

const route = express.Router()

route.post('/permissoes', verifyJWT, postPermissoes)
route.use(base)

export { route as perfis }

esse é o base router 

import express from 'express'
import { AuthController } from 'src/controllers/'

const baseRoute = (controler, auth = false) => {
	const route = express.Router()
	const { verifyJWT } = AuthController()
	const { all, fetch, one, post, put, del } = controler()

	if (auth) {
		route.get(`/`, verifyJWT, fetch)
		route.get(`/all`, verifyJWT, all)
		route.get(`/:id`, verifyJWT, one)
	} else {
		route.get(`/`, fetch)
		route.get(`/all`, all)
		route.get(`/:id`, one)
	}
	route.post(`/`, verifyJWT, post)
	route.put(`/:id`, verifyJWT, put)
	route.delete(`/:id`, verifyJWT, del)

	return route
}

export default baseRoute





gostaria de uma fn de desconectar campos e de reestruturar parapara o padrão Controller, Use Case, Factory e Repository. Quero os nomes de arquivos separados por kebab-case
quero tambem  se o controller pegar um erro nao tratado apenas lance esse erro a diante sem fazer reply tembem ajuste o nome dele para ser mais semantico quero a resposta no seguinte formato Estrutura de Arquivos src/ ├── modules/ │   ├── example/ │   │   ├── controllers/ │   │   │   └── example-controller.ts │   │   ├── use-cases/ │   │   │   └── example-use-case.ts │   │   ├── factories/ │   │   │   └── make-example-use-case.ts │   │   └── repositories/ │   │       example-repository.ts │   │       └── implementations/ │   │           └── prisma-example-repository.ts nome dos arquivos que vão ser criados repository interface para criar o contrato repository implement controller factory use case

quero trocar o express pelo fastify e o prisma pode manter